# Project Name
## Test Report

### 1. Introduction

The Underwatch project is divided into two major and one minor components. Namely:

1. Game (major)
2. Web Page (major)
3. Backend (minor)

We chose this classification since the major business logic of our project is implement in either the web page or the game respectively. 
The Backend merely serves as an mostly auto-generated RESTful API which comes with SpringBoot out of the box.

Each component requires a seperate testing methodology which we are going to break down in this document.

### 2. Test Strategy

#### Backend Tests

As described previously, we are using the SpringBootRest template within our project. They do their very own testing of edge cases and general functionality which you can check out in their [GitHub/Jenkins](https://github.com/spring-projects/spring-data-rest).

Nevertheless we do implement some functionality here which can be easily covered by unit tests.
For the setup we chose the following software testing stack:

- JUnit5
- SpringFramework

By injecting an in-memory database into the framework we're able to insert, modify and delete records in a unit test.

#### Web Page Tests

As the Web Page is a visual representation of code in the browser, unit testing a web page does only provide minimal use. 
However, since we taking advantage of the React Library, which comes with a handy `React Testing Library` we are able to at least test the functionality of components.

To make the web page tests complete, there are manual (integration) tests neccessary, before a build gets deployed to production.

#### Game Tests

Sadly the LibGDX Framework did not come with a proper implementation of a `headless` backend, not allowing us to unit test many components of this subsystem by writing test cases.
Because of this fact our testing strategy for the game was split into two major parts (of which one is quite time-consuming).

Unit tests are created for all statically available code, which has no dependency on a LibGDX (or GPU) backend.

Additionally manual integration testing is conducted extensively before a build is depoloyed.

### 3. Test Plan
> This section outlines the specific testing tasks, timelines, and resources required to achieve the testing objectives.

### 4. Test Cases
> This section details the specific test cases that were executed, including their pass/fail status and any defects found during testing. (You may link to the repository of your use cases.)

### 5. Test Results 
> This section summarizes the results of the testing, including major defects found, their severity, and the steps taken to resolve them. (You may link to the test reports generated by your testing tool.)

### 6. Metrics
> This section provides quantitative data on the testing process, such as the number of defects found, the defect resolution time, and the test coverage achieved.

### 7. Recommendations
> This section offers suggestions for improving the testing process and the quality of the software.

### 8. Conclusion
> This section summarizes the key findings of the testing and the overall status of the software quality.
